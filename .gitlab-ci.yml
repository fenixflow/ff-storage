# Targeted GitLab CI/CD pipeline for Fenix packages
# - Pipelines run automatically only when a package version file changes on main branch
# - Builds rely on `uv build` for reproducible wheels
# - All packages auto-publish to GitLab Package Registry when their versions change
# - ff-logger and ff-storage have manual gates for publishing to PyPI and GitHub

workflow:
  rules:
    # Only run on main branch when pyproject.toml changes
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - ff-logger/pyproject.toml
        - ff-storage/pyproject.toml
        - ff-cli/pyproject.toml
        - ff-parsers/pyproject.toml
    # Allow manual pipeline triggers from web UI
    - if: '$CI_PIPELINE_SOURCE == "web"'
    - when: never

stages:
  - build
  - test
  - publish_gitlab
  - publish_pypi
  - mirror_github

variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  UV_CACHE_DIR: "$CI_PROJECT_DIR/.cache/uv"
  PYTHON_VERSION: "3.12"
  GIT_DEPTH: "0"

cache:
  paths:
    - .cache/pip
    - .cache/uv

default:
  image: python:${PYTHON_VERSION}-slim
  before_script:
    - apt-get update && apt-get install -y git curl
    - curl -LsSf https://astral.sh/uv/install.sh | sh
    - source $HOME/.local/bin/env
    - export PATH="/root/.local/bin:$PATH"
    - uv --version
    - python --version

# Build stage for validation
.build_template: &build_template
  stage: build
  script:
    - |
      set -euo pipefail
      echo "========================================"
      echo "Building package: ${PACKAGE}"
      echo "========================================"

      PACKAGE_DIR="${CI_PROJECT_DIR}/${PACKAGE}"
      cd "${PACKAGE_DIR}"

      echo "Cleaning previous build artifacts..."
      rm -rf dist build *.egg-info src/*.egg-info 2>/dev/null || true

      echo "Building wheel with uv..."
      uv build

      echo "✅ Build successful for ${PACKAGE}"
  artifacts:
    paths:
      - ${PACKAGE}/dist/
    expire_in: 1 hour

# Test stage for validation
.test_template: &test_template
  stage: test
  script:
    - |
      set -euo pipefail
      echo "========================================"
      echo "Testing package: ${PACKAGE}"
      echo "========================================"

      PACKAGE_DIR="${CI_PROJECT_DIR}/${PACKAGE}"
      cd "${PACKAGE_DIR}"

      echo "Installing package with test dependencies..."
      uv pip install --system -e ".[dev]"

      echo "Running tests..."
      pytest tests/ || true  # Don't fail on test errors for now

      echo "✅ Tests completed for ${PACKAGE}"

# GitLab publish template
.publish_gitlab_template: &publish_gitlab_template
  stage: publish_gitlab
  script:
    - |
      set -euo pipefail
      echo "========================================"
      echo "GitLab publish for: ${PACKAGE}"
      echo "========================================"

      PACKAGE_DIR="${CI_PROJECT_DIR}/${PACKAGE}"
      cd "${PACKAGE_DIR}"

      echo "Cleaning previous build artifacts..."
      rm -rf dist build *.egg-info src/*.egg-info 2>/dev/null || true

      echo "Building wheel with uv..."
      uv build

      VERSION=$(python3 -c 'import tomllib; from pathlib import Path; print(tomllib.loads(Path("pyproject.toml").read_text())["project"]["version"])')
      echo "Package version: ${VERSION}"

      WHEEL_FILE=$(find dist -maxdepth 1 -name "*.whl" -print -quit)
      if [ -z "${WHEEL_FILE}" ]; then
        echo "❌ No wheel artifact produced for ${PACKAGE}"
        exit 1
      fi
      WHEEL_NAME=$(basename "${WHEEL_FILE}")

      PACKAGE_UNDERSCORE="${PACKAGE//-/_}"
      PACKAGE_NORMALIZED=$(python3 -c 'import re, sys; print(re.sub(r"[-_.]+", "-", sys.argv[1]).lower())' "${PACKAGE}")
      CHECK_URL="${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/pypi/files/${PACKAGE_NORMALIZED}/${VERSION}/${WHEEL_NAME}"

      echo "Checking for existing artifact in GitLab registry..."
      if curl -s -o /dev/null -w "%{http_code}" --head --header "JOB-TOKEN: ${CI_JOB_TOKEN}" "${CHECK_URL}" | grep -qE "^(200|302)$"; then
        echo "✅ ${PACKAGE} ${VERSION} already exists in GitLab registry. Skipping upload."
        exit 0
      fi

      echo "Publishing ${PACKAGE} ${VERSION} to GitLab registry..."
      printf '[distutils]\nindex-servers = gitlab\n\n[gitlab]\nrepository = %s/projects/%s/packages/pypi\nusername = gitlab-ci-token\npassword = %s\n' \
        "${CI_API_V4_URL}" \
        "${CI_PROJECT_ID}" \
        "${CI_JOB_TOKEN}" \
        > ~/.pypirc

      uv pip install --system twine
      python -m twine upload --repository gitlab dist/* --verbose
      echo "✅ GitLab publish complete for ${PACKAGE} ${VERSION}"

# PyPI publish template
.publish_pypi_template: &publish_pypi_template
  stage: publish_pypi
  id_tokens:
    PYPI_ID_TOKEN:
      aud: pypi
  script:
    - |
      set -euo pipefail
      echo "========================================"
      echo "PyPI publish for: ${PACKAGE}"
      echo "========================================"

      PACKAGE_DIR="${CI_PROJECT_DIR}/${PACKAGE}"
      cd "${PACKAGE_DIR}"

      echo "Cleaning previous build artifacts..."
      rm -rf dist build *.egg-info src/*.egg-info 2>/dev/null || true

      echo "Building wheel with uv..."
      uv build

      VERSION=$(python3 -c 'import tomllib; from pathlib import Path; print(tomllib.loads(Path("pyproject.toml").read_text())["project"]["version"])')
      echo "Package version: ${VERSION}"

      echo "Verifying ${PACKAGE} ${VERSION} does not already exist on PyPI..."
      PACKAGE_UNDERSCORE="${PACKAGE//-/_}"
      if pip index versions "${PACKAGE_UNDERSCORE}" 2>/dev/null | grep -q "^Available versions:.*${VERSION}"; then
        echo "❌ ${PACKAGE} ${VERSION} already exists on PyPI."
        echo "Please bump the version before publishing."
        exit 1
      fi

      uv pip install --system twine
      python -m twine upload --non-interactive --verbose dist/*
      echo "✅ PyPI publish complete for ${PACKAGE} ${VERSION}"

# GitHub mirror template
.mirror_github_template: &mirror_github_template
  stage: mirror_github
  script:
    - |
      set -euo pipefail
      echo "========================================"
      echo "GitHub mirror for: ${PACKAGE}"
      echo "========================================"

      if [ -z "${GITHUB_TOKEN:-}" ]; then
        echo "❌ GITHUB_TOKEN not set. Skipping GitHub mirror."
        exit 0
      fi

      PACKAGE_DIR="${CI_PROJECT_DIR}/${PACKAGE}"
      cd "${PACKAGE_DIR}"

      VERSION=$(python3 -c 'import tomllib; from pathlib import Path; print(tomllib.loads(Path("pyproject.toml").read_text())["project"]["version"])')
      echo "Package version: ${VERSION}"

      echo "Setting up git credentials..."
      git config --global user.email "ci@fenixflow.com"
      git config --global user.name "Fenix CI"

      echo "Creating temporary clone for ${PACKAGE}..."
      TEMP_DIR=$(mktemp -d)
      cd "${TEMP_DIR}"

      echo "Cloning GitHub repository..."
      git clone --depth 1 "https://${GITHUB_TOKEN}@github.com/fenixflow/${PACKAGE}.git" || {
        echo "❌ Failed to clone GitHub repository. Repository may not exist."
        exit 0
      }

      cd "${PACKAGE}"

      echo "Syncing files from GitLab..."
      rsync -av --delete --exclude=.git/ "${PACKAGE_DIR}/" .

      echo "Committing changes..."
      git add -A
      git commit -m "Mirror from GitLab: ${PACKAGE} v${VERSION}" || {
        echo "No changes to commit."
        exit 0
      }

      echo "Creating version tag..."
      git tag -a "v${VERSION}" -m "Version ${VERSION}" || true

      echo "Pushing to GitHub..."
      git push origin main --tags

      echo "✅ GitHub mirror complete for ${PACKAGE} ${VERSION}"

      # Cleanup
      cd /
      rm -rf "${TEMP_DIR}"

# Build jobs
build:ff-cli:
  <<: *build_template
  variables:
    PACKAGE: "ff-cli"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - ff-cli/pyproject.toml
      when: on_success
    - when: never

build:ff-parsers:
  <<: *build_template
  variables:
    PACKAGE: "ff-parsers"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - ff-parsers/pyproject.toml
      when: on_success
    - when: never

build:ff-logger:
  <<: *build_template
  variables:
    PACKAGE: "ff-logger"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - ff-logger/pyproject.toml
      when: on_success
    - when: never

build:ff-storage:
  <<: *build_template
  variables:
    PACKAGE: "ff-storage"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - ff-storage/pyproject.toml
      when: on_success
    - when: never

# Test jobs
test:ff-cli:
  <<: *test_template
  variables:
    PACKAGE: "ff-cli"
  needs:
    - build:ff-cli
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - ff-cli/pyproject.toml
      when: on_success
    - when: never

test:ff-parsers:
  <<: *test_template
  variables:
    PACKAGE: "ff-parsers"
  needs:
    - build:ff-parsers
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - ff-parsers/pyproject.toml
      when: on_success
    - when: never

test:ff-logger:
  <<: *test_template
  variables:
    PACKAGE: "ff-logger"
  needs:
    - build:ff-logger
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - ff-logger/pyproject.toml
      when: on_success
    - when: never

test:ff-storage:
  <<: *test_template
  variables:
    PACKAGE: "ff-storage"
  needs:
    - build:ff-storage
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - ff-storage/pyproject.toml
      when: on_success
    - when: never

# GitLab publish jobs - ALL automatic
publish:gitlab:ff-cli:
  <<: *publish_gitlab_template
  variables:
    PACKAGE: "ff-cli"
  needs:
    - test:ff-cli
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - ff-cli/pyproject.toml
      when: on_success
    - when: never

publish:gitlab:ff-parsers:
  <<: *publish_gitlab_template
  variables:
    PACKAGE: "ff-parsers"
  needs:
    - test:ff-parsers
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - ff-parsers/pyproject.toml
      when: on_success
    - when: never

publish:gitlab:ff-logger:
  <<: *publish_gitlab_template
  variables:
    PACKAGE: "ff-logger"
  needs:
    - test:ff-logger
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - ff-logger/pyproject.toml
      when: on_success  # Changed from manual to on_success
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: on_success
    - when: never

publish:gitlab:ff-storage:
  <<: *publish_gitlab_template
  variables:
    PACKAGE: "ff-storage"
  needs:
    - test:ff-storage
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - ff-storage/pyproject.toml
      when: on_success  # Changed from manual to on_success
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: on_success
    - when: never

# PyPI publish jobs - Manual for ff-logger and ff-storage
publish:pypi:ff-logger:
  <<: *publish_pypi_template
  variables:
    PACKAGE: "ff-logger"
  needs:
    - job: publish:gitlab:ff-logger
      optional: true
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - ff-logger/pyproject.toml
      when: manual
      allow_failure: false
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
      allow_failure: false
    - when: never

publish:pypi:ff-storage:
  <<: *publish_pypi_template
  variables:
    PACKAGE: "ff-storage"
  needs:
    - job: publish:gitlab:ff-storage
      optional: true
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - ff-storage/pyproject.toml
      when: manual
      allow_failure: false
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
      allow_failure: false
    - when: never

# GitHub mirror jobs - Manual for ff-logger and ff-storage
mirror:github:ff-logger:
  <<: *mirror_github_template
  variables:
    PACKAGE: "ff-logger"
  needs:
    - job: publish:gitlab:ff-logger
      optional: true
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - ff-logger/pyproject.toml
      when: manual
      allow_failure: true
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
      allow_failure: true
    - when: never

mirror:github:ff-storage:
  <<: *mirror_github_template
  variables:
    PACKAGE: "ff-storage"
  needs:
    - job: publish:gitlab:ff-storage
      optional: true
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - ff-storage/pyproject.toml
      when: manual
      allow_failure: true
    - if: '$CI_PIPELINE_SOURCE == "web"'
      when: manual
      allow_failure: true
    - when: never